/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
const { isEqual } = require('lodash')

// 给你两个下标从 0 开始且长度为 n 的整数数组 nums1 和 nums2 ，两者都是 [0, 1, ..., n - 1] 的 排列 。
// 好三元组 指的是 3 个 互不相同 的值，且它们在数组 nums1 和 nums2 中出现顺序保持一致。换句话说，如果我们将 pos1v 记为值 v 在 nums1 中出现的位置，pos2v 为值 v 在 nums2 中的位置，
// 那么一个好三元组定义为 0 <= x, y, z <= n - 1 ，且 pos1x < pos1y < pos1z 和 pos2x < pos2y < pos2z 都成立的 (x, y, z) 。
// 请你返回好三元组的 总数目 。

/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var goodTriplets = function(nums1, nums2) {
  const len = nums1.length;
  let map = new Map();
  for (let i = 0; i < len; i++) {
    map.set(nums2[i], i);
  }
  
  let ans = 0;
  const bit = new Bit(len);
  for (let i = 0; i < len; i++) {
    const id2 = map.get(nums1[i]);
    const left = bit.sum(id2);
    const right = len - (bit.sum(len - 1) - bit.sum(id2)) - id2 - 1;
    ans += left * right;
    bit.add(id2, 1);
  }
  
  return ans;
};

class Bit {
  constructor (n) {
    this.len = n + 1;
    this.arr = new Array(n + 1).fill(0);
  }
  
  add (x, y) {
    for (x += 1; x <= this.len; x += x & -x) this.arr[x] += y;
  }
  
  sum (x) {
    let res = 0;
    for (let i = x + 1; i > 0; i -= i & -i) res += this.arr[i];
    return res;
  }
}

console.log(isEqual(goodTriplets([2, 0, 1, 3], [0, 1, 2, 3]), 1))
console.log(isEqual(goodTriplets([4, 0, 1, 3, 2], [4, 1, 0, 2, 3]), 4))

// 首先用哈希表记录每个数在数组二中的位置，然后按照数组一的顺序依次处理。
//
// 我们考虑以当前数字作为三元组中间数字的好三元组的数目。第一个数字需要是之前已经遍历过的，并且在数组二中的位置比当前数字更靠前的；第三个数字需要是当前还没有遍历过的，并且在数组二中的位置比当前数字更靠后的。这里只对数字的位置有要求，而对数字具体的值没有要求。
//
// 如何快速求出满足条件的第一个数字和第三个数字的个数呢？
//
// 以 [4,0,1,3,2]\quad[4,1,0,2,3][4,0,1,3,2][4,1,0,2,3]为例，考虑我们的遍历过程：
//
// 首先处理的是 4，此时数组二中的出现情况为：
//
// [4,X,X,X,X][4,X,X,X,X]
//
// 我们需要统计的是 4 之前的有值的个数（0 个），以及 4 之后的没有值的个数（4 个）。因此以 4 为中间数字能形成 0 个好三元组。
//
// 接下来是 0，此时数组二中的出现情况为：
//
// [4,X,0,X,X][4,X,0,X,X]
//
// 0 之前有值的个数（1 个），0 之后没有值的个数（2 个）。因此以 0 为中间数字能形成 2 个好三元组。
//
// 接下来是 1，此时数组二中的出现情况为：
//
// [4,1,0,X,X][4,1,0,X,X]
//
// 1 之前有值的个数（1 个），1 之后没有值的个数（2 个）。因此以 1 为中间数字能形成 2 个好三元组。
//
// 接下来是 3，此时数组二中的出现情况为：
//
// [4,1,0,X,3][4,1,0,X,3]
//
// 3 之前有值的个数（3 个），3 之后没有值的个数（0 个）。因此以 3 为中间数字能形成 0 个好三元组。
//
// 最后是 2，此时数组二中的出现情况为：
//
// [4,1,0,2,3][4,1,0,2,3]
//
// 2 之前有值的个数（3 个），2 之后没有值的个数（0 个）。因此以 2 为中间数字能形成 0 个好三元组。
//
// 最后的答案是 4。
//
// 因为我们并不关心数字具体的值，而只关心是否出现过，所以我们实际上可以把数组二的出现情况用一个 0C1 数组来表示：
//
// [1,0,0,0,0]\rightarrow[1,0,1,0,0]\rightarrow[1,1,1,0,0]\rightarrow[1,1,1,0,1]\rightarrow[1,1,1,1,1][1,0,0,0,0]→[1,0,1,0,0]→[1,1,1,0,0]→[1,1,1,0,1]→[1,1,1,1,1]
//
// 这时可以看出，我们用树状数组（或者线段树）就能快速更新状态，并求出我们需要的两个数值（左边的 1 的个数和右边的 0 的个数）。
//
// 理清思路之后，代码的实现是比较容易的。

